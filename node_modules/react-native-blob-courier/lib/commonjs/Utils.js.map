{"version":3,"sources":["Utils.tsx"],"names":["createUuidPart","Math","random","toString","substring","uuid","intersectObjects","primary","secondary","Set","Object","keys","concat","reduce","p","c","undefined","unionObjects","fallbackObjects","fallback","primaryAndFallbackUnified","allUniqueKeys","childWithFallback","convertMappedMultipartsWithSymbolizedKeysToArray","mappedParts","symbolKeys","getOwnPropertySymbols","map","symbolName","name","Symbol","keyFor","sanitizeMappedMultiparts","mapped","regularKeys","receivedRegularKeys","length","receivedSymbolKeys","receivedMixedKeys","receivedInvalidSymbols","filter","_","Error","for"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Ely Deckers.\n *\n * This source code is licensed under the MPL-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type { BlobNamedMultipartArray, BlobMultipart } from './ExposedTypes';\n\n// Taken from https://github.com/joltup/rn-fetch-blob/blob/master/utils/uuid.js\nconst createUuidPart = () => Math.random().toString(36).substring(2, 15);\n\nexport const uuid = () => `${createUuidPart()}${createUuidPart()}`;\n\nexport const intersectObjects = (\n  primary: { [key: string]: any },\n  secondary: { [key: string]: any }\n) =>\n  [...new Set(Object.keys(primary).concat(Object.keys(secondary)))].reduce(\n    (p, c) =>\n      c in primary && c in secondary\n        ? {\n            ...p,\n            [c]: primary[c] !== undefined ? primary[c] : secondary[c],\n          }\n        : p,\n    {}\n  ) as { [key: string]: any };\n\nexport const unionObjects = (\n  primary: { [key: string]: any },\n  secondary: { [key: string]: any }\n) =>\n  [...new Set(Object.keys(primary).concat(Object.keys(secondary)))].reduce(\n    (p, c) =>\n      c in primary && c in secondary\n        ? {\n            ...p,\n            [c]: primary[c] !== undefined ? primary[c] : secondary[c],\n          }\n        : {\n            ...p,\n            [c]: c in primary ? primary[c] : secondary[c],\n          },\n    {}\n  ) as { [key: string]: any };\n\nexport const fallbackObjects = (\n  primary: { [key: string]: any },\n  fallback: { [key: string]: any }\n): { [key: string]: any } => {\n  const primaryAndFallbackUnified = unionObjects(primary, fallback);\n\n  const allUniqueKeys = [...new Set(Object.keys(primaryAndFallbackUnified))];\n\n  return allUniqueKeys.reduce((p, c) => {\n    if (typeof fallback[c] === 'object') {\n      const childWithFallback = fallbackObjects(\n        typeof primary[c] === 'object' ? primary[c] : {}, // Fallback object is leading, so either primary is an object or we're ignoring it\n        fallback[c]\n      );\n\n      return {\n        ...p,\n        [c]: childWithFallback,\n      };\n    }\n\n    return {\n      ...p,\n      [c]: primary[c] !== undefined ? primary[c] : fallback[c],\n    };\n  }, {});\n};\n\nexport const convertMappedMultipartsWithSymbolizedKeysToArray = (mappedParts: {\n  [key: string]: BlobMultipart;\n}): BlobNamedMultipartArray => {\n  const symbolKeys = Object.getOwnPropertySymbols(mappedParts);\n\n  return symbolKeys.map((symbolName: any) => ({\n    ...mappedParts[symbolName],\n    name: Symbol.keyFor(symbolName) ?? '',\n  }));\n};\n\nexport const sanitizeMappedMultiparts = (mapped: {\n  [key: string]: BlobMultipart;\n}) => {\n  const regularKeys = Object.keys(mapped);\n  const symbolKeys = Object.getOwnPropertySymbols(mapped);\n\n  const receivedRegularKeys = regularKeys.length > 0;\n  const receivedSymbolKeys = symbolKeys.length > 0;\n\n  const receivedMixedKeys = receivedRegularKeys && receivedSymbolKeys;\n\n  const receivedInvalidSymbols =\n    receivedSymbolKeys &&\n    symbolKeys.map(Symbol.keyFor).filter((_) => _ === undefined).length > 0;\n\n  if (receivedMixedKeys) {\n    throw new Error('Either use all Symbols or all Strings as multipart keys');\n  }\n\n  if (receivedInvalidSymbols) {\n    throw new Error('Use Symbol.for when using Symbols as key for multiparts');\n  }\n\n  return regularKeys.length > 0\n    ? regularKeys.reduce(\n        (p, c) => ({\n          ...p,\n          [Symbol.for(c)]: mapped[c],\n        }),\n        {}\n      )\n    : mapped;\n};\n"]}